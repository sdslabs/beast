package config

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"time"

	"github.com/sdslabs/beastv4/core"
	"github.com/sdslabs/beastv4/utils"

	"github.com/BurntSushi/toml"
	log "github.com/sirupsen/logrus"
)

// This is the global beast configuration structure
//
// An example of a config file
//
// ```toml
// # Authorized key file used by ssh daemon running on the host
// # This is used for forwarding ssh connection to docker containers, the
// # access to a container is only given to the author of the challenge.
// authorized_keys_file = "/home/fristonio/.beast/beast_authorized_keys"
//
//
// # Directory which will contain all the autogenerated scripts by beast
// # These scripts are the heart to above authorized keys file. Each entry in authorized
// # keys file as a corresponding script which is executed during an SSH attempt.
// scripts_dir = "/home/fristonio/.beast/scripts"
//
//
// # Base OS image that beast allows the challenges to use.
// allowed_base_images = ["ubuntu:18.04", "ubuntu:16.04", "debian:jessie"]
//
//
// # For authentication purposes beast uses JWT based authentication, this is the
// # key used for encrypting the claims of a user. Keep this strong.
// jwt_secret = "beast_jwt_secret_SUPER_STRONG_0x100010000100"
//
//
// # To allow beast to send notification to a notification channel povide this webhook URL
// # We are also working on implmeneting notification using Discord and IRC.
// slack_webhook = ""
//
//
// # The sidecar that we support with beast, currently we only support two MySQL and
// # MongoDB.
// available_sidecars = ["mysql", "mongodb"]
//
//
// # The frequency for any periodic event in beast, the value is provided in seconds.
// # This is currently only used for health check periodic duration.s
// ticker_frequency = 3000
//
//
// # Container default resource limits for each challenge, this can be
// # Overridden by challenge configuration beast.toml file.
// default_cpu_shares = 1024
// default_memory_limit = 1024
// default_pids_limit = 100
//
//
// # Configuration corresponding to the remote repository used by beast
// # We use ssh authentication mechanism for interacting with git repository.
// [remote]
//
// # URL of the remote git repository, this should be user@host:<git_repository> format
// url = "git@github.com:sdslabs/hack-test.git"
//
// # Name of the remote
// name = "hack-test"
//
// # Branch we are tracking the remote in beast.
// branch = "master"
//
// # Path to private SSH key for interacting with the git repository.
// ssh_key = "/home/fristonio/.beast/secrets/key.priv"
// ```
type BeastConfig struct {
	AuthorizedKeysFile string    `toml:"authorized_keys_file"`
	BeastScriptsDir    string    `toml:"scripts_dir"`
	AllowedBaseImages  []string  `toml:"allowed_base_images"`
	AvailableSidecars  []string  `toml:"available_sidecars"`
	GitRemote          GitRemote `toml:"remote"`
	JWTSecret          string    `toml:"jwt_secret"`
	SlackWebHookURL    string    `toml:"slack_webhook"`
	DiscordWebHookURL  string    `toml:"disocrd_webhook"`
	TickerFrequency int `toml:"ticker_frequency"`

	RemoteSyncPeriod time.Duration `toml:"-"`
	Rsp              string        `toml:"remote_sync_period"`

	CPUShares int64 `toml:"default_cpu_shares"`
	Memory    int64 `toml:"default_memory_limit"`
	PidsLimit int64 `toml:"default_pids_limit"`
}

func (config *BeastConfig) ValidateConfig() error {
	log.Debug("Validating BeastConfig structure")

	if config.AuthorizedKeysFile != "" {
		err := utils.CreateFileIfNotExist(config.AuthorizedKeysFile)
		if err != nil {
			log.Errorf("Error while creating authorized_keys file : %s", config.AuthorizedKeysFile)
		}

		config.AuthorizedKeysFile, err = filepath.Abs(config.AuthorizedKeysFile)
		if err != nil {
			return fmt.Errorf("Error while getting absolute path : %s", err)
		}
	} else {
		defaultAuthKeyFile := filepath.Join(os.Getenv("HOME"), core.DEFAULT_AUTH_KEYS_FILE)
		log.Warnf("No authorized_keys file path provided, using default : %s", defaultAuthKeyFile)
		config.AuthorizedKeysFile = defaultAuthKeyFile
	}

	if config.BeastScriptsDir == "" {
		defaultBeastScriptDir := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_SCRIPTS_DIR)
		log.Warn("No scripts directory provided for beast, using default : %s", defaultBeastScriptDir)
		config.BeastScriptsDir = defaultBeastScriptDir
	} else {
		err := utils.CreateIfNotExistDir(config.BeastScriptsDir)
		if err != nil {
			log.Error("Error while creating beast scripts directory")
			return err
		}
	}

	if !utils.StringInSlice(core.DEFAULT_BASE_IMAGE, config.AllowedBaseImages) {
		config.AllowedBaseImages = append(config.AllowedBaseImages, core.DEFAULT_BASE_IMAGE)
	}

	if config.JWTSecret == "" {
		log.Error("The secret string is empty in beast config")
		return fmt.Errorf("Invalid config")
	}

	err := config.GitRemote.ValidateGitConfig()
	if err != nil {
		return err
	}

	if config.TickerFrequency <= 0 {
		log.Debug("Time is not provided or is less than equal to zero so default time is taken")
		config.TickerFrequency = core.DEFAULT_TICKER_FREQUENCY
	}

	if config.Rsp == "" {
		log.Debug("Time is not provided or is less than equal to zero so default time is taken")
		config.RemoteSyncPeriod = core.DEFAULT_REMOTE_PERIODIC_SYNC_TIME
	} else {
		duration, err := time.ParseDuration(config.Rsp)
		if err != nil || duration < core.DEFAULT_REMOTE_PERIODIC_SYNC_TIME {
			log.Debug("Invalid format of provided time or the time too less(must be > 120s) for beast remote periodic sync")
			config.RemoteSyncPeriod = core.DEFAULT_REMOTE_PERIODIC_SYNC_TIME
		} else {
			config.RemoteSyncPeriod = duration
		}
	}

	if config.CPUShares <= 0 {
		log.Debug("Per container CPU shares not provided using default value")
		config.CPUShares = core.DEFAULT_CPU_SHARE
	}

	if config.Memory <= 0 {
		log.Debug("Per container Memory Limit not provided using default value")
		config.Memory = core.DEFAULT_MEMORY_LIMIT
	}

	if config.PidsLimit <= 0 {
		log.Debug("Per container Pids Limit not provided using default value")
		config.PidsLimit = core.DEFAULT_PIDS_LIMIT
	}

	return nil
}

type GitRemote struct {
	Url        string `toml:"url"`
	RemoteName string `toml:"name"`
	Branch     string `toml:"branch"`
	Secret     string `toml:"ssh_key"`
}

func (config *GitRemote) ValidateGitConfig() error {
	if config.Url == "" || config.RemoteName == "" || config.Secret == "" {
		log.Error("One of url, RemoteName or ssh_key is missing in the config")
		return errors.New("Git remote config not valid, config parameters missing")
	}

	gitUrlRegexp, err := regexp.Compile(config.Url)
	if err != nil {
		eMsg := fmt.Errorf("Error while compiling git url regex : %s", err)
		return eMsg
	}

	if !gitUrlRegexp.MatchString(config.Url) {
		return errors.New("The provided git url is not valid.")
	}

	if config.Branch == "" {
		log.Warn("Branch for git remote not provided, using %s", core.GIT_REMOTE_DEFAULT_BRANCH)
		config.Branch = core.GIT_REMOTE_DEFAULT_BRANCH
	}

	err = utils.ValidateFileExists(config.Secret)
	log.Debugf("Using git ssh secret : %s", config.Secret)
	if err != nil {
		return fmt.Errorf("Provided ssh key file(%s) does not exists : %s", config.Secret, err)
	}

	return nil
}

// From the path of the config file provided as an arguement this function
// loads the parse the config file and load it into the BeastConfig
// structure. After parsing it validates the data in the config file and returns
// error if the validation fails.
func LoadBeastConfig(configPath string) (BeastConfig, error) {
	var config BeastConfig

	err := utils.ValidateFileExists(configPath)
	if err != nil {
		return config, err
	}

	_, err = toml.DecodeFile(configPath, &config)
	if err != nil {
		return config, err
	}

	log.Debugf("Parsed beast global config file is : %s", config)
	err = config.ValidateConfig()
	if err != nil {
		return config, err
	}

	log.Debug("Global beast config file config.toml has been verified")
	return config, nil
}

// Update the USED_PORT_LIST variable in config.
// Don't do this very often, we do this once during syncing the git repository
// then whenever you need updated used port list you need to sync the git remote
// by beast.
func UpdateUsedPortList() {
	USED_PORTS_LIST = make([]uint32, 0)

	beastRemoteDir := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_REMOTES_DIR)
	challengeDir := filepath.Join(beastRemoteDir, Cfg.GitRemote.RemoteName, core.BEAST_REMOTE_CHALLENGE_DIR)

	dirs := utils.GetAllDirectoriesName(challengeDir)
	for _, dir := range dirs {
		configFilePath := filepath.Join(dir, core.CHALLENGE_CONFIG_FILE_NAME)
		var config BeastChallengeConfig
		_, err := toml.DecodeFile(configFilePath, &config)
		if err == nil {
			USED_PORTS_LIST = append(USED_PORTS_LIST, config.Challenge.Env.Ports...)
		}
	}

	log.Debugf("Used port list updated: %v", USED_PORTS_LIST)
}

var Cfg BeastConfig = InitConfig()
var SkipAuthorization bool
var USED_PORTS_LIST []uint32

func InitConfig() BeastConfig {
	configPath := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_CONFIG_FILE_NAME)
	cfg, err := LoadBeastConfig(configPath)

	if err != nil {
		log.Errorf("Error while loading the beast global config : %s", err)
		os.Exit(1)
	}

	log.Debugf("CONFIG LOAD: New Config : %v", cfg)
	return cfg
}

func ReloadBeastConfig() error {
	configPath := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_CONFIG_FILE_NAME)
	cfg, err := LoadBeastConfig(configPath)

	if err != nil {
		return fmt.Errorf("Error while loading beast config: %s", err)
	}

	Cfg = cfg
	log.Debugf("CONFIG LOAD: New Config : %v", Cfg)
	return nil
}
