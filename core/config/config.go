package config

import (
	"errors"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"time"

	"github.com/sdslabs/beastv4/core"
	"github.com/sdslabs/beastv4/utils"

	"github.com/BurntSushi/toml"
	log "github.com/sirupsen/logrus"
)

// This is the global beast configuration structure
//
// # An example of a config file
//
// ```toml
// # Authorized key file used by ssh daemon running on the host
// # This is used for forwarding ssh connection to docker containers, the
// # access to a container is only given to the author, maintainers of challenge and admin.
// authorized_keys_file = "/home/fristonio/.beast/beast_authorized_keys"
//
// # Directory which will contain all the autogenerated scripts by beast
// # These scripts are the heart to above authorized keys file. Each entry in authorized
// # keys file as a corresponding script which is executed during an SSH attempt.
// scripts_dir = "/home/fristonio/.beast/scripts"
//
// # Base OS image that beast allows the challenges to use.
// allowed_base_images = ["ubuntu:18.04", "ubuntu:16.04", "debian:jessie"]
//
// # Beast static URL refers to the host used by beast for serving static content
// # of the challenges, whenever required. It follows the URL pattern like
// # [beast_static_url]/static/[chall_dir]/[file_name]
// beast_static_url = "http://hack.sdslabs.co:8034"
//
// # For authentication purposes beast uses JWT based authentication, this is the
// # key used for encrypting the claims of a user. Keep this strong.
// jwt_secret = "beast_jwt_secret_SUPER_STRONG_0x100010000100"
//
// # To allow beast to send notification to a notification channel povide this webhook URL
// # We are also working on implmeneting notification using Discord and IRC.
// slack_webhook = ""
//
// # The sidecar that we support with beast, currently we only support two MySQL and
// # MongoDB.
// available_sidecars = ["mysql", "mongodb"]
//
// # The frequency for any periodic event in beast, the value is provided in seconds.
// # This is currently only used for health check periodic duration.s
// ticker_frequency = 3000
//
// # Container default resource limits for each challenge, this can be
// # Overridden by challenge configuration beast.toml file.
// default_cpu_shares = 1024
// default_memory_limit = 1024
// default_pids_limit = 100
//
// # Configuration corresponding to the remote repository used by beast
// # We use ssh authentication mechanism for interacting with git repository.
// [remote]
//
// # URL of the remote git repository, this should be user@host:<git_repository> format
// url = "git@github.com:sdslabs/hack-test.git"
//
// # Name of the remote
// name = "hack-test"
//
// # Branch we are tracking the remote in beast.
// branch = "master"
//
// # Path to private SSH key for interacting with the git repository.
// ssh_key = "/home/fristonio/.beast/secrets/key.priv"
//
// # Mail config parameters for SMTP configuration
// from = ""
// password = ""
// smtpHost = ""
// smtpPort = ""
// ```
type BeastConfig struct {
	AuthorizedKeysFile   string                `toml:"authorized_keys_file"`
	BeastScriptsDir      string                `toml:"scripts_dir"`
	AllowedBaseImages    []string              `toml:"allowed_base_images"`
	AvailableSidecars    []string              `toml:"available_sidecars"`
	GitRemotes           []GitRemote           `toml:"remote"`
	JWTSecret            string                `toml:"jwt_secret"`
	NotificationWebhooks []NotificationWebhook `toml:"notification_webhooks"`
	CompetitionInfo      CompetitionInfo       `toml:"competition_info"`
	BeastStaticUrl       string                `toml:"beast_static_url"`
	TickerFrequency      int                   `toml:"ticker_frequency"`

	RemoteSyncPeriod time.Duration `toml:"-"`
	Rsp              string        `toml:"remote_sync_period"`

	CPUShares int64 `toml:"default_cpu_shares"`
	Memory    int64 `toml:"default_memory_limit"`
	PidsLimit int64 `toml:"default_pids_limit"`

	// For SMTP Configuration
	MailConfig MailConfig `toml:"mail_config"`
}

func (config *BeastConfig) ValidateConfig() error {
	log.Debug("Validating BeastConfig structure")

	if config.AuthorizedKeysFile != "" {
		err := utils.CreateFileIfNotExist(config.AuthorizedKeysFile)
		if err != nil {
			log.Errorf("Error while creating authorized_keys file : %s", config.AuthorizedKeysFile)
		}

		config.AuthorizedKeysFile, err = filepath.Abs(config.AuthorizedKeysFile)
		if err != nil {
			return fmt.Errorf("Error while getting absolute path : %s", err)
		}
	} else {
		defaultAuthKeyFile := filepath.Join(os.Getenv("HOME"), core.DEFAULT_AUTH_KEYS_FILE)
		log.Warnf("No authorized_keys file path provided, using default : %s", defaultAuthKeyFile)
		config.AuthorizedKeysFile = defaultAuthKeyFile
	}

	if config.BeastScriptsDir == "" {
		defaultBeastScriptDir := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_SCRIPTS_DIR)
		log.Warn("No scripts directory provided for beast, using default : %s", defaultBeastScriptDir)
		config.BeastScriptsDir = defaultBeastScriptDir
	} else {
		err := utils.CreateIfNotExistDir(config.BeastScriptsDir)
		if err != nil {
			log.Error("Error while creating beast scripts directory")
			return err
		}
	}

	_, err := url.Parse(config.BeastStaticUrl)

	if err != nil {
		return fmt.Errorf("Invalid beast static URL provided : %s", config.BeastStaticUrl)
	}

	if !utils.StringInSlice(core.DEFAULT_BASE_IMAGE, config.AllowedBaseImages) {
		config.AllowedBaseImages = append(config.AllowedBaseImages, core.DEFAULT_BASE_IMAGE)
	}

	if config.JWTSecret == "" {
		log.Error("The secret string is empty in beast config")
		return fmt.Errorf("Invalid config")
	}

	for _, gitRemote := range config.GitRemotes {
		if gitRemote.Active == true {
			err := gitRemote.ValidateGitConfig()
			if err != nil {
				return fmt.Errorf("Error while validating config : %s", gitRemote.RemoteName)
			}
		}
	}

	if config.TickerFrequency <= 0 {
		log.Debug("Time is not provided or is less than equal to zero so default time is taken")
		config.TickerFrequency = core.DEFAULT_TICKER_FREQUENCY
	}

	if config.Rsp == "" {
		log.Debug("Time is not provided or is less than equal to zero so default time is taken")
		config.RemoteSyncPeriod = core.DEFAULT_REMOTE_PERIODIC_SYNC_TIME
	} else {
		duration, err := time.ParseDuration(config.Rsp)
		if err != nil || duration < core.DEFAULT_REMOTE_PERIODIC_SYNC_TIME {
			log.Debug("Invalid format of provided time or the time too less(must be > 120s) for beast remote periodic sync")
			config.RemoteSyncPeriod = core.DEFAULT_REMOTE_PERIODIC_SYNC_TIME
		} else {
			config.RemoteSyncPeriod = duration
		}
	}

	if config.CPUShares <= 0 {
		log.Debug("Per container CPU shares not provided using default value")
		config.CPUShares = core.DEFAULT_CPU_SHARE
	}

	if config.Memory <= 0 {
		log.Debug("Per container Memory Limit not provided using default value")
		config.Memory = core.DEFAULT_MEMORY_LIMIT
	}

	if config.PidsLimit <= 0 {
		log.Debug("Per container Pids Limit not provided using default value")
		config.PidsLimit = core.DEFAULT_PIDS_LIMIT
	}

	if config.MailConfig.From == "" || config.MailConfig.Password == "" || config.MailConfig.SMTPHost == "" || config.MailConfig.SMTPPort == "" {
		log.Warn("Mail configuration not provided, email notifications will not work")
	}

	return nil
}

type GitRemote struct {
	Url        string `toml:"url"`
	RemoteName string `toml:"name"`
	Branch     string `toml:"branch"`
	Secret     string `toml:"ssh_key"`
	Active     bool   `toml:"active"`
}

func (config *GitRemote) ValidateGitConfig() error {
	if config.Url == "" || config.RemoteName == "" || config.Secret == "" {
		log.Error("One of url, RemoteName or ssh_key is missing in the config")
		return errors.New("Git remote config not valid, config parameters missing")
	}

	gitUrlRegexp, err := regexp.Compile(config.Url)
	if err != nil {
		eMsg := fmt.Errorf("Error while compiling git url regex : %s", err)
		return eMsg
	}

	if !gitUrlRegexp.MatchString(config.Url) {
		return errors.New("The provided git url is not valid.")
	}

	if config.Branch == "" {
		log.Warn("Branch for git remote not provided, using %s", core.GIT_REMOTE_DEFAULT_BRANCH)
		config.Branch = core.GIT_REMOTE_DEFAULT_BRANCH
	}

	err = utils.ValidateFileExists(config.Secret)
	log.Debugf("Using git ssh secret : %s", config.Secret)
	if err != nil {
		return fmt.Errorf("Provided ssh key file(%s) does not exists : %s", config.Secret, err)
	}

	return nil
}

type NotificationWebhook struct {
	URL         string `toml:"url"`
	ServiceName string `toml:"service_name"`
	Active      bool   `toml:"active"`
}

type CompetitionInfo struct {
	Name         string `toml:"name"`
	About        string `toml:"about"`
	Prizes       string `toml:"prizes"`
	StartingTime string `toml:"starting_time"`
	EndingTime   string `toml:"ending_time"`
	TimeZone     string `toml:"timezone"`
	LogoURL      string `toml:"logo_url"`
	DynamicScore bool   `toml:"dynamic_score"`
}

type MailConfig struct {
	From     string `toml:"from"`
	Password string `toml:"password"`
	SMTPHost string `toml:"smtpHost"`
	SMTPPort string `toml:"smtpPort"`
}

func UpdateCompetitionInfo(competitionInfo *CompetitionInfo) error {
	configPath := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_CONFIG_FILE_NAME)
	var config BeastConfig

	err := utils.ValidateFileExists(configPath)
	if err != nil {
		return err
	}

	_, err = toml.DecodeFile(configPath, &config)
	if err != nil {
		return err
	}

	config.CompetitionInfo = *competitionInfo

	configFile, err := os.Create(configPath)
	if err != nil {
		return err
	}

	if err := toml.NewEncoder(configFile).Encode(config); err != nil {
		return err
	}

	if err := configFile.Close(); err != nil {
		return err
	}
	return err
}

func GetCompetitionInfo() (CompetitionInfo, error) {
	configPath := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_CONFIG_FILE_NAME)
	var config BeastConfig
	var competitionInfo CompetitionInfo

	err := utils.ValidateFileExists(configPath)
	if err != nil {
		return competitionInfo, err
	}

	_, err = toml.DecodeFile(configPath, &config)
	if err != nil {
		return competitionInfo, err
	}

	return config.CompetitionInfo, nil
}

// From the path of the config file provided as an arguement this function
// loads the parse the config file and load it into the BeastConfig
// structure. After parsing it validates the data in the config file and returns
// error if the validation fails.
func LoadBeastConfig(configPath string) (BeastConfig, error) {
	var config BeastConfig

	err := utils.ValidateFileExists(configPath)
	if err != nil {
		return config, err
	}

	_, err = toml.DecodeFile(configPath, &config)
	if err != nil {
		return config, err
	}

	log.Debugf("Parsed beast global config file is : %s", config)
	err = config.ValidateConfig()
	if err != nil {
		return config, err
	}

	log.Debug("Global beast config file config.toml has been verified")
	return config, nil
}

// Update the USED_PORT_LIST variable in config.
// Don't do this very often, we do this once during syncing the git repository
// then whenever you need updated used port list you need to sync the git remote
// by beast.
func UpdateUsedPortList() {
	USED_PORTS_LIST = make([]uint32, 0)

	beastRemoteDir := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_REMOTES_DIR)

	for _, gitRemote := range Cfg.GitRemotes {
		if gitRemote.Active != true {
			continue
		}

		challengeDir := filepath.Join(beastRemoteDir, gitRemote.RemoteName, core.BEAST_REMOTE_CHALLENGE_DIR)
		dirs := utils.GetAllDirectoriesName(challengeDir)
		for _, dir := range dirs {
			configFilePath := filepath.Join(dir, core.CHALLENGE_CONFIG_FILE_NAME)
			var config BeastChallengeConfig
			_, err := toml.DecodeFile(configFilePath, &config)
			if err == nil {
				hostPorts, err := config.Challenge.Env.GetAllHostPorts()
				if err != nil {
					log.Errorf("Error while parsing host ports for challenge %s", dir)
					continue
				}

				USED_PORTS_LIST = append(USED_PORTS_LIST, hostPorts...)
			}
		}
	}
	log.Debugf("Used port list updated: %v", USED_PORTS_LIST)
}

var Cfg *BeastConfig
var SkipAuthorization bool
var NoCache bool
var USED_PORTS_LIST []uint32

// InitConfig loads the config from the global config file and populate
// the Cfg global variable used everywhere else.
func InitConfig() {
	log.Info("Loading up beast configuration.")
	if Cfg != nil {
		log.Warn("Config is already initialized, reinitilize/reload using ReloadBeastConfig method")
		return
	}
	configPath := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_CONFIG_FILE_NAME)
	cfg, err := LoadBeastConfig(configPath)

	if err != nil {
		log.Errorf("Error while loading the beast global config : %s", err)
		os.Exit(1)
	}

	log.Debugf("CONFIG LOAD: New Config : %v", cfg)
	Cfg = &cfg
}

// ReloadBeastConfig reloads the beast configuration and reinitializes the Cfg global
// variable.
func ReloadBeastConfig() error {
	configPath := filepath.Join(core.BEAST_GLOBAL_DIR, core.BEAST_CONFIG_FILE_NAME)
	cfg, err := LoadBeastConfig(configPath)

	if err != nil {
		return fmt.Errorf("Error while loading beast config: %s", err)
	}

	Cfg = &cfg
	log.Debugf("CONFIG LOAD: New Config : %v", cfg)
	return nil
}
